/*! \page page-overview Overview
GSI-sMINRES is a library of MINRES-based methods for solving **many shifted linear systems** on shared-memory/HPC environments.  
We target Hermitian (real-symmetric) matrices \f$A\f$ and Hermitian positive-definite matrices \f$B\f$.

## Problem classes
- **Standard shifted systems**
  \f[
    (A+\sigma^{(m)} I)\,\boldsymbol{x}^{(m)} = \boldsymbol{b},
    \qquad m=1,2,\dots,M.
  \f]
- **Generalized shifted systems**
  \f[
    (A+\sigma^{(m)} B)\,\boldsymbol{x}^{(m)} = \boldsymbol{b},
    \qquad m=1,2,\dots,M.
  \f]

Here \f$\sigma^{(m)} \in \mathbb{C}\f$ are the shifts, \f$I\f$ is the identity, and \f$\boldsymbol{x}^{(m)}\f$ are the unknowns (bold for vectors).

## Provided methods
- \ref page-alg-std  "Standard shifted MINRES (sMINRES)"
- \ref page-alg-gen  "Generalized shifted MINRES (gsMINRES)"
- \ref page-alg-sis  "Shift–invert preconditioned shifted MINRES (SiS-MINRES)"

A concise algorithmic summary for each method is given under \ref page-algorithms "Algorithms".

## Assumptions & scope
- \f$A\f$ is Hermitian (real-symmetric allowed); \f$B\f$ is Hermitian positive-definite.
- Complex arithmetic is supported; real cases are covered as a subset.
- Stopping criterion is typically the relative residual
  \f$\|\boldsymbol{r}_k\|/\|\boldsymbol{r}_0\|\le \texttt{rtol}\f$ (method pages detail the exact rule).

## API layout (entry points)
- \ref gsi_sminres::standard::Solver     "gsi_sminres::standard::Solver"
- \ref gsi_sminres::generalized::Solver  "gsi_sminres::generalized::Solver"
- \ref gsi_sminres::shift_invert::Solver "gsi_sminres::shift_invert::Solver"

Each solver exposes a common high-level workflow (initialize → Lanczos pre/post or single step → per-shift update → finalize).  
For a flow diagram, see \ref page-behavior "Library behavior image".

## Data formats & I/O
**Library core is format-agnostic.** The solvers operate on vector-level BLAS
updates internally; users are expected to supply the required operators:
- \f$ \boldsymbol{y} \leftarrow A \boldsymbol{x} \f$ (matrix–vector product)
- For generalized / sis variants, \f$\boldsymbol{y} \leftarrow B^{-1}\boldsymbol{x}\f$ / \f$\boldsymbol{y} \leftarrow (A + \omega B)^{-1}\boldsymbol{x}\f$.

To make examples immediately runnable, we provide minimal utilities for two
common paths:

- **CSR (sparse) path** — for large sparse systems  
  Headers under `extras/{io,sparse}` offer Matrix Market loaders and SpMV:  
  e.g. `load_mm_csr(...)` and CSR SpMV helpers (see `mm_csr.hpp`, `csr.hpp`, `spmv.hpp`).  

- **Packed Hermitian (BLAS/LAPACK) path** — for densd HPD systems  
  Matrix Market → packed storage via `load_mm_zhp(...)`, then call BLAS/LAPACK
  (e.g., `zhpmv`, `zpptrf`/`zpptrs`) through the lightweight wrappers
  (see `blas_zhpmv.hpp`, `lapack.hpp`, `mm_zhp.hpp`). This path is used by
  the ZHP-based examples.

Example inputs and small drivers live under `examples/`. Check the corresponding
headers for exact function signatures.

## Quick navigation
- \ref page-algorithms "Algorithms"  •  \ref page-install "Installation"  •  \ref page-license "License & Contacts"
*/
